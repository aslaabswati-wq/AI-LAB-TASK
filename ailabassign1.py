# -*- coding: utf-8 -*-
"""AiLabAssign1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r7HvvJrxKlHaKJVIMf5o4lZvIcwiU1Ci
"""

from collections import deque

graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}
def bfs(graph, start):
    visited = []
    queue = deque([start])

    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.append(node)
            queue.extend(graph[node])

    return visited
def dfs(graph, start, visited=None):
    if visited is None:
        visited = []

    visited.append(start)
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph, neighbor, visited)

    return visited
print("Graph Representation:", graph)
print("BFS Traversal:", bfs(graph, 'A'))
print("DFS Traversal:", dfs(graph, 'A'))

student = {
    "name": "Ali Khan",
    "age": 20,
    "roll_number": "BSE-123",
    "grade": "B"
}

print("Original Student Dictionary:")
for key, value in student.items():
    print(f"{key}: {value}")
student["grade"] = "A"
print("\nAfter Updating Grade:")
print(student)

student["email"] = "alikhan@example.com"
print("\nAfter Adding Email:")
print(student)


del student["roll_number"]
print("\nAfter Deleting Roll Number:")
print(student)

import matplotlib.pyplot as plt

X = [1, 2, 3, 4, 5]
Y = [2, 4, 6, 8, 10]

plt.plot(X, Y, marker='o', color='blue', linestyle='solid')

plt.title("Simple Line Plot")
plt.xlabel("X-axis")
plt.ylabel("Y-axis")

plt.grid(True)

plt.show()

from collections import deque
import time
import tracemalloc

def water_jug_bfs(X, Y, target):
    visited = set()
    queue = deque([(0, 0)])
    path = []

    while queue:
        state = queue.popleft()
        a, b = state

        if state in visited:
            continue
        visited.add(state)
        path.append(state)


        if a == target or b == target:
            return path


        next_states = set()

        next_states.add((X, b))
        next_states.add((a, Y))

        next_states.add((0, b))
        next_states.add((a, 0))

        pour = min(a, Y - b)
        next_states.add((a - pour, b + pour))

        pour = min(b, X - a)
        next_states.add((a + pour, b - pour))

        for n in next_states:
            if n not in visited:
                queue.append(n)

    return []

def water_jug_dfs(X, Y, target, visited=None, path=None, state=(0, 0)):
    if visited is None:
        visited = set()
    if path is None:
        path = []

    a, b = state
    if state in visited:
        return None

    visited.add(state)
    path.append(state)

    if a == target or b == target:
        return path

    next_states = [
        (X, b), (a, Y),
        (0, b), (a, 0),
        (a - min(a, Y - b), b + min(a, Y - b)),
        (a + min(b, X - a), b - min(b, X - a))
    ]

    for n in next_states:
        if n not in visited:
            result = water_jug_dfs(X, Y, target, visited, path.copy(), n)
            if result:
                return result

    return None
def compare_algorithms(X, Y, target):
    print("Comparing BFS and DFS for Water Jug Problem:\n")

    # BFS
    start_time = time.time()
    tracemalloc.start()
    bfs_path = water_jug_bfs(X, Y, target)
    bfs_memory = tracemalloc.get_traced_memory()[1]
    tracemalloc.stop()
    bfs_time = time.time() - start_time

    # DFS
    start_time = time.time()
    tracemalloc.start()
    dfs_path = water_jug_dfs(X, Y, target)
    dfs_memory = tracemalloc.get_traced_memory()[1]
    tracemalloc.stop()
    dfs_time = time.time() - start_time

    print("BFS Path:", bfs_path)
    print("DFS Path:", dfs_path)
    print("\n--- Performance Comparison ---")
    print(f"BFS Steps: {len(bfs_path)} | Time: {bfs_time:.6f}s | Memory: {bfs_memory} bytes")
    print(f"DFS Steps: {len(dfs_path)} | Time: {dfs_time:.6f}s | Memory: {dfs_memory} bytes")

compare_algorithms(X=4, Y=3, target=2)

from heapq import heappush, heappop
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 0, 1, 0, 0],
    [0, 0, 0, 0, 0]
]

start = (0, 0)
goal = (4, 4)

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def astar(maze, start, goal):
    rows, cols = len(maze), len(maze[0])
    open_set = []
    heappush(open_set, (0, start))
    came_from = {}
    g_score = {start: 0}

    while open_set:
        current_f, current = heappop(open_set)

        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
        for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
            neighbor = (current[0] + dx, current[1] + dy)

            if 0 <= neighbor[0] < rows and 0 <= neighbor[1] < cols and maze[neighbor[0]][neighbor[1]] == 0:
                temp_g = g_score[current] + 1
                if neighbor not in g_score or temp_g < g_score[neighbor]:
                    g_score[neighbor] = temp_g
                    f_score = temp_g + heuristic(neighbor, goal)
                    heappush(open_set, (f_score, neighbor))
                    came_from[neighbor] = current

    return None

path = astar(maze, start, goal)

if path:
    print("Path found by A* Search:")
    for step in path:
        print(step)
else:
    print("No path found!")