# -*- coding: utf-8 -*-
"""A*Algo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11n_iaRXwRtwpTnh5LYZ6Efs_vRWV6Pyn
"""

from collections import deque

JUG1, JUG2, GOAL = 4, 3, 1

def water_jug_bfs():
    start = (0, 0)
    queue = deque([start])
    parent = {start: None}  # store parent state

    while queue:
        x, y = queue.popleft()

        if x == GOAL or y == GOAL:
            # reconstruct path
            path = []
            state = (x, y)
            while state is not None:
                path.append(state)
                state = parent[state]
            return path[::-1]

        moves = [
            (JUG1, y),  # fill jug1
            (x, JUG2),  # fill jug2
            (0, y),     # empty jug1
            (x, 0),     # empty jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),  # pour jug1â†’jug2
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))   # pour jug2â†’jug1
        ]

        for nxt in moves:
            if nxt not in parent:
                parent[nxt] = (x, y)
                queue.append(nxt)
    return None

# Run
solution = water_jug_bfs()
print("BFS Solution path:")
for step in solution:
    print(step)

JUG1, JUG2, GOAL = 4, 3, 1

def water_jug_dfs():
    start = (0, 0)
    stack = [start]
    parent = {start: None}

    while stack:
        state = stack.pop()

        if state[0] == GOAL or state[1] == GOAL:
            # reconstruct path
            path = []
            while state is not None:
                path.append(state)
                state = parent[state]
            return path[::-1]

        x, y = state
        moves = [
            (JUG1, y),  # fill jug1
            (x, JUG2),  # fill jug2
            (0, y),     # empty jug1
            (x, 0),     # empty jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),  # pour jug1â†’jug2
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))   # pour jug2â†’jug1
        ]

        for nxt in moves:
            if nxt not in parent:  # not visited
                parent[nxt] = state
                stack.append(nxt)
    return None

# Run
solution = water_jug_dfs()
print("DFS Solution path:")
for step in solution:
    print(step)

import heapq

import heapq

JUG1, JUG2, GOAL = 4, 3, 1

def heuristic(state):
    x, y = state
    return min(abs(x - GOAL), abs(y - GOAL))

def a_star_water_jug():
    start = (0, 0)
    open_list = [(heuristic(start), 0, start)]  # (f, g, state)
    parent = {start: None}

    while open_list:
        f, g, state = heapq.heappop(open_list)

        if state[0] == GOAL or state[1] == GOAL:
            # reconstruct path
            path = []
            while state is not None:
                path.append(state)
                state = parent[state]
            return path[::-1]

        x, y = state
        moves = [
            (JUG1, y),  # fill jug1
            (x, JUG2),  # fill jug2
            (0, y),     # empty jug1
            (x, 0),     # empty jug2
            (x - min(x, JUG2 - y), y + min(x, JUG2 - y)),  # pour jug1â†’jug2
            (x + min(y, JUG1 - x), y - min(y, JUG1 - x))   # pour jug2â†’jug1
        ]

        for nxt in moves:
            if nxt not in parent:  # not visited
                parent[nxt] = state
                new_g = g + 1
                new_f = new_g + heuristic(nxt)
                heapq.heappush(open_list, (new_f, new_g, nxt))
    return None

# Run
solution = a_star_water_jug()
print("A* Solution path:")
for step in solution:
    print(step)

"""ANSWER NO 1
When we solve the water jug problem with BFS, DFS, and A*, the paths they find are not always the same.

BFS finds the solution path:

(0, 0) â†’ (4, 0) â†’ (1, 3)
ANSWER NO 2
This is the shortest path with only 2 moves.

DFS gives a longer path, for example:

(0, 0) â†’ (0, 3) â†’ (4, 3) â†’ (4, 0) â†’ (1, 3)

ANSWER NO 3
It eventually reaches the goal but takes extra steps.

A*, thanks to the heuristic, also finds the shortest path:

(0, 0) â†’ (4, 0) â†’ (1, 3)

Which gives the shortest path?

BFS and A* both find the shortest path. DFS does not guarantee thatâ€”it just goes deep until it stumbles upon a solution, which may be longer.

Time and memory efficiency:

BFS checks every state level by level, so it always finds the shortest path, but it can be slow and use a lot of memory.

DFS uses very little memory because it just goes down one branch at a time, but it wastes time exploring long or useless paths and doesnâ€™t always give the shortest answer.

A* is usually the most efficient: it uses the heuristic to guide the search, expands fewer states than BFS, and still finds the shortest path as long as the heuristic is good. Its memory use is higher than DFS but usually better than BFS.

ðŸ‘‰ In short:

BFS = guaranteed shortest path, but heavy on memory.

DFS = light on memory, but not reliable for shortest path.

A* = combines the best of both; itâ€™s usually the fastest and still gives the shortest path.
"""